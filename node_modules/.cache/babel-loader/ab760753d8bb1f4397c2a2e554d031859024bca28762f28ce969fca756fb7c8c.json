{"ast":null,"code":"var _jsxFileName = \"/mnt/devplex/Nightland/nightland/src/components/Combat.js\",\n  _s = $RefreshSig$();\n// nightland/src/components/Combat.js\nimport React, { useEffect } from 'react';\nimport { updateCombatDialogs } from '../modules/utils';\nimport Dialog from './Dialog';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Combat = ({\n  state,\n  dispatch\n}) => {\n  _s();\n  useEffect(() => {\n    var _state$combatTurn;\n    console.log('Combat useEffect - State:', {\n      inCombat: state.inCombat,\n      combatTurn: (_state$combatTurn = state.combatTurn) === null || _state$combatTurn === void 0 ? void 0 : _state$combatTurn.name,\n      attackSlots: state.attackSlots\n    });\n    combatStep(state, dispatch);\n  }, [state.combatTurn]);\n  const dialogData = updateCombatDialogs(\"\", state.attackSlots.map(slot => slot.monster.lastComment || \"\"), state.player, state.attackSlots.map(slot => slot.monster));\n  console.log('Combat Render - Dialog Data:', dialogData);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"combat\",\n    children: [/*#__PURE__*/_jsxDEV(Dialog, {\n      data: dialogData.player,\n      index: \"player\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 17,\n      columnNumber: 13\n    }, this), dialogData.enemies.map((enemy, i) => enemy && /*#__PURE__*/_jsxDEV(Dialog, {\n      data: enemy,\n      index: i\n    }, i, false, {\n      fileName: _jsxFileName,\n      lineNumber: 19,\n      columnNumber: 17\n    }, this))]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 16,\n    columnNumber: 9\n  }, this);\n};\n_s(Combat, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = Combat;\nlet roundNumber = 1;\nfunction combatStep(state, dispatch) {\n  if (!state.inCombat || !state.turnOrder.length) return;\n  const current = state.combatTurn;\n  const currentIndex = state.turnOrder.indexOf(current);\n  const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n  let allMonsters = state.attackSlots.map(slot => slot.monster);\n  let playerComment = \"\";\n  let enemyComments = allMonsters.map(() => \"\");\n  if (currentIndex > 1 || roundNumber > 1) {\n    updateCombatDialogs(\"\", allMonsters.map(() => \"\"), state.player, allMonsters);\n  }\n  if (current === state.player) {\n    const target = activeMonsters[0];\n    if (target) {\n      if (Math.random() < 0.8) {\n        target.hp -= 6;\n        playerComment = \"You hit for 6 points!\";\n        enemyComments = allMonsters.map(slot => slot === target && slot.hp <= 0 ? \"Monster is dead!\" : \"\");\n        if (target.hp <= 0) {\n          calculateTurnOrder(state, dispatch);\n        }\n      } else {\n        playerComment = \"You miss!\";\n      }\n    }\n  } else if (activeMonsters.includes(current)) {\n    const monsterIndex = allMonsters.indexOf(current);\n    const isFirstLivingMonster = currentIndex === 1 && allMonsters.some(m => m && m.hp <= 0);\n    if (isFirstLivingMonster) {\n      const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n      allMonsters = newAttackSlots.map(slot => slot.monster);\n      dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n          inCombat: true,\n          attackSlots: newAttackSlots\n        }\n      });\n      for (let i = 1; i <= 4; i++) {\n        const enemyDiv = document.getElementById(`combat-enemy-${i}`);\n        if (enemyDiv && enemyDiv.style.display !== 'none') {\n          enemyDiv.classList.remove('flicker');\n          enemyDiv.classList.add('flicker');\n          setTimeout(() => enemyDiv.classList.remove('flicker'), 500);\n        }\n      }\n    }\n    if (Math.random() < 0.5) {\n      const newHp = state.player.hp - 4;\n      enemyComments[monsterIndex] = \"He hit you for 4 points!\";\n      allMonsters[monsterIndex].lastComment = \"He hit you for 4 points!\";\n      dispatch({\n        type: 'UPDATE_PLAYER_HP',\n        payload: {\n          hp: newHp\n        }\n      });\n    } else {\n      enemyComments[monsterIndex] = \"He missed you!\";\n      allMonsters[monsterIndex].lastComment = \"He missed you!\";\n    }\n  }\n  console.log('Combat Step - Player Comment:', playerComment, 'Enemy Comments:', enemyComments);\n  updateCombatDialogs(playerComment, enemyComments, state.player, allMonsters);\n  if (state.player.hp <= 0) {\n    updateCombatDialogs(\"You have perished!\", activeMonsters.map(() => \"Victory over the human!\"), state.player, allMonsters);\n    endCombat(state, dispatch);\n  } else if (activeMonsters.length === 0 && state.waitingMonsters.length === 0) {\n    updateCombatDialogs(\"Victory is yours!\", allMonsters.map(() => \"\"), state.player, allMonsters);\n    endCombat(state, dispatch);\n  } else {\n    dispatch({\n      type: 'SET_COMBAT',\n      payload: {\n        inCombat: true,\n        attackSlots: state.attackSlots,\n        turnOrder: state.turnOrder,\n        combatTurn: state.turnOrder[(currentIndex + 1) % state.turnOrder.length]\n      }\n    });\n    moveWaitingMonsters(state, dispatch);\n    if (current === state.turnOrder[state.turnOrder.length - 1]) {\n      resolveRound(state, dispatch);\n      calculateTurnOrder(state, dispatch);\n      roundNumber++;\n    }\n  }\n}\nfunction calculateTurnOrder(state, dispatch) {\n  const combatants = [state.player, ...state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0)];\n  const newTurnOrder = combatants.filter(c => c.hp > 0);\n  dispatch({\n    type: 'SET_COMBAT',\n    payload: {\n      inCombat: state.inCombat,\n      attackSlots: state.attackSlots,\n      turnOrder: newTurnOrder,\n      combatTurn: newTurnOrder[0]\n    }\n  });\n}\nfunction resolveRound(state, dispatch) {\n  const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n  const deadMonsters = state.attackSlots.filter(slot => slot.monster && slot.monster.hp <= 0);\n  if (deadMonsters.length > 0) {\n    deadMonsters.forEach(slot => {\n      slot.monster.active = false;\n      if (state.waitingMonsters.length > 0) {\n        const nextMonster = state.waitingMonsters.shift();\n        nextMonster.x = slot.position.x;\n        nextMonster.y = slot.position.y;\n        slot.monster = nextMonster;\n      } else {\n        slot.monster = null;\n      }\n    });\n    const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n    dispatch({\n      type: 'SET_COMBAT',\n      payload: {\n        inCombat: true,\n        attackSlots: newAttackSlots\n      }\n    });\n  }\n  moveWaitingMonsters(state, dispatch);\n  calculateTurnOrder(state, dispatch);\n}\nfunction moveWaitingMonsters(state, dispatch) {\n  const activeMonsters = state.activeMonsters.filter(m => m.active && m.hp > 0);\n  const allAttackSlotsFull = state.attackSlots.length >= state.maxAttackers;\n  activeMonsters.forEach(monster => {\n    if (monster.hp > 0 && !state.attackSlots.some(slot => slot.monster === monster)) {\n      const dx = Math.abs(monster.x - state.player.x);\n      const dy = Math.abs(monster.y - state.player.y);\n      if (allAttackSlotsFull && (dx <= 2 || dy <= 2)) {\n        if (!state.waitingMonsters.includes(monster)) {\n          dispatch({\n            type: 'UPDATE_WAITING_MONSTERS',\n            payload: {\n              waitingMonsters: [...state.waitingMonsters, monster]\n            }\n          });\n        }\n      }\n    }\n  });\n}\nfunction endCombat(state, dispatch) {\n  dispatch({\n    type: 'SET_COMBAT',\n    payload: {\n      inCombat: false,\n      attackSlots: [],\n      waitingMonsters: [],\n      turnOrder: [],\n      combatTurn: null\n    }\n  });\n  roundNumber = 1;\n}\nexport default Combat;\nvar _c;\n$RefreshReg$(_c, \"Combat\");","map":{"version":3,"names":["React","useEffect","updateCombatDialogs","Dialog","jsxDEV","_jsxDEV","Combat","state","dispatch","_s","_state$combatTurn","console","log","inCombat","combatTurn","name","attackSlots","combatStep","dialogData","map","slot","monster","lastComment","player","className","children","data","index","fileName","_jsxFileName","lineNumber","columnNumber","enemies","enemy","i","_c","roundNumber","turnOrder","length","current","currentIndex","indexOf","activeMonsters","filter","m","hp","allMonsters","playerComment","enemyComments","target","Math","random","calculateTurnOrder","includes","monsterIndex","isFirstLivingMonster","some","newAttackSlots","s","type","payload","enemyDiv","document","getElementById","style","display","classList","remove","add","setTimeout","newHp","endCombat","waitingMonsters","moveWaitingMonsters","resolveRound","combatants","newTurnOrder","c","deadMonsters","forEach","active","nextMonster","shift","x","position","y","allAttackSlotsFull","maxAttackers","dx","abs","dy","$RefreshReg$"],"sources":["/mnt/devplex/Nightland/nightland/src/components/Combat.js"],"sourcesContent":["// nightland/src/components/Combat.js\nimport React, { useEffect } from 'react';\nimport { updateCombatDialogs } from '../modules/utils';\nimport Dialog from './Dialog';\n\nconst Combat = ({ state, dispatch }) => {\n    useEffect(() => {\n        console.log('Combat useEffect - State:', { inCombat: state.inCombat, combatTurn: state.combatTurn?.name, attackSlots: state.attackSlots });\n        combatStep(state, dispatch);\n    }, [state.combatTurn]);\n\n    const dialogData = updateCombatDialogs(\"\", state.attackSlots.map(slot => slot.monster.lastComment || \"\"), state.player, state.attackSlots.map(slot => slot.monster));\n    console.log('Combat Render - Dialog Data:', dialogData);\n\n    return (\n        <div className=\"combat\">\n            <Dialog data={dialogData.player} index=\"player\" />\n            {dialogData.enemies.map((enemy, i) => enemy && (\n                <Dialog key={i} data={enemy} index={i} />\n            ))}\n        </div>\n    );\n};\n\nlet roundNumber = 1;\n\nfunction combatStep(state, dispatch) {\n    if (!state.inCombat || !state.turnOrder.length) return;\n\n    const current = state.combatTurn;\n    const currentIndex = state.turnOrder.indexOf(current);\n    const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n    let allMonsters = state.attackSlots.map(slot => slot.monster);\n    let playerComment = \"\";\n    let enemyComments = allMonsters.map(() => \"\");\n\n    if (currentIndex > 1 || roundNumber > 1) {\n        updateCombatDialogs(\"\", allMonsters.map(() => \"\"), state.player, allMonsters);\n    }\n\n    if (current === state.player) {\n        const target = activeMonsters[0];\n        if (target) {\n            if (Math.random() < 0.8) {\n                target.hp -= 6;\n                playerComment = \"You hit for 6 points!\";\n                enemyComments = allMonsters.map(slot => slot === target && slot.hp <= 0 ? \"Monster is dead!\" : \"\");\n                if (target.hp <= 0) {\n                    calculateTurnOrder(state, dispatch);\n                }\n            } else {\n                playerComment = \"You miss!\";\n            }\n        }\n    } else if (activeMonsters.includes(current)) {\n        const monsterIndex = allMonsters.indexOf(current);\n        const isFirstLivingMonster = currentIndex === 1 && allMonsters.some(m => m && m.hp <= 0);\n        if (isFirstLivingMonster) {\n            const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n            allMonsters = newAttackSlots.map(slot => slot.monster);\n            dispatch({ type: 'SET_COMBAT', payload: { inCombat: true, attackSlots: newAttackSlots } });\n            for (let i = 1; i <= 4; i++) {\n                const enemyDiv = document.getElementById(`combat-enemy-${i}`);\n                if (enemyDiv && enemyDiv.style.display !== 'none') {\n                    enemyDiv.classList.remove('flicker');\n                    enemyDiv.classList.add('flicker');\n                    setTimeout(() => enemyDiv.classList.remove('flicker'), 500);\n                }\n            }\n        }\n\n        if (Math.random() < 0.5) {\n            const newHp = state.player.hp - 4;\n            enemyComments[monsterIndex] = \"He hit you for 4 points!\";\n            allMonsters[monsterIndex].lastComment = \"He hit you for 4 points!\";\n            dispatch({ type: 'UPDATE_PLAYER_HP', payload: { hp: newHp } });\n        } else {\n            enemyComments[monsterIndex] = \"He missed you!\";\n            allMonsters[monsterIndex].lastComment = \"He missed you!\";\n        }\n    }\n\n    console.log('Combat Step - Player Comment:', playerComment, 'Enemy Comments:', enemyComments);\n    updateCombatDialogs(playerComment, enemyComments, state.player, allMonsters);\n\n    if (state.player.hp <= 0) {\n        updateCombatDialogs(\"You have perished!\", activeMonsters.map(() => \"Victory over the human!\"), state.player, allMonsters);\n        endCombat(state, dispatch);\n    } else if (activeMonsters.length === 0 && state.waitingMonsters.length === 0) {\n        updateCombatDialogs(\"Victory is yours!\", allMonsters.map(() => \"\"), state.player, allMonsters);\n        endCombat(state, dispatch);\n    } else {\n        dispatch({\n            type: 'SET_COMBAT',\n            payload: {\n                inCombat: true,\n                attackSlots: state.attackSlots,\n                turnOrder: state.turnOrder,\n                combatTurn: state.turnOrder[(currentIndex + 1) % state.turnOrder.length]\n            }\n        });\n        moveWaitingMonsters(state, dispatch);\n\n        if (current === state.turnOrder[state.turnOrder.length - 1]) {\n            resolveRound(state, dispatch);\n            calculateTurnOrder(state, dispatch);\n            roundNumber++;\n        }\n    }\n}\n\nfunction calculateTurnOrder(state, dispatch) {\n    const combatants = [state.player, ...state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0)];\n    const newTurnOrder = combatants.filter(c => c.hp > 0);\n    dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n            inCombat: state.inCombat,\n            attackSlots: state.attackSlots,\n            turnOrder: newTurnOrder,\n            combatTurn: newTurnOrder[0]\n        }\n    });\n}\n\nfunction resolveRound(state, dispatch) {\n    const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n    const deadMonsters = state.attackSlots.filter(slot => slot.monster && slot.monster.hp <= 0);\n\n    if (deadMonsters.length > 0) {\n        deadMonsters.forEach(slot => {\n            slot.monster.active = false;\n            if (state.waitingMonsters.length > 0) {\n                const nextMonster = state.waitingMonsters.shift();\n                nextMonster.x = slot.position.x;\n                nextMonster.y = slot.position.y;\n                slot.monster = nextMonster;\n            } else {\n                slot.monster = null;\n            }\n        });\n        const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n        dispatch({ type: 'SET_COMBAT', payload: { inCombat: true, attackSlots: newAttackSlots } });\n    }\n\n    moveWaitingMonsters(state, dispatch);\n    calculateTurnOrder(state, dispatch);\n}\n\nfunction moveWaitingMonsters(state, dispatch) {\n    const activeMonsters = state.activeMonsters.filter(m => m.active && m.hp > 0);\n    const allAttackSlotsFull = state.attackSlots.length >= state.maxAttackers;\n    activeMonsters.forEach(monster => {\n        if (monster.hp > 0 && !state.attackSlots.some(slot => slot.monster === monster)) {\n            const dx = Math.abs(monster.x - state.player.x);\n            const dy = Math.abs(monster.y - state.player.y);\n            if (allAttackSlotsFull && (dx <= 2 || dy <= 2)) {\n                if (!state.waitingMonsters.includes(monster)) {\n                    dispatch({\n                        type: 'UPDATE_WAITING_MONSTERS',\n                        payload: { waitingMonsters: [...state.waitingMonsters, monster] }\n                    });\n                }\n            }\n        }\n    });\n}\n\nfunction endCombat(state, dispatch) {\n    dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n            inCombat: false,\n            attackSlots: [],\n            waitingMonsters: [],\n            turnOrder: [],\n            combatTurn: null\n        }\n    });\n    roundNumber = 1;\n}\n\nexport default Combat;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}