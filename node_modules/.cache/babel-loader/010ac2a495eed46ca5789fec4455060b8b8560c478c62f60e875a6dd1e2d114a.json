{"ast":null,"code":"// nightland/src/modules/gameLoop.js\nimport { updateCombatDialogs } from './utils';\nlet roundNumber = 1; // From combat.js, moved here for now\n\nexport function handleMovePlayer(state, dispatch, key, showDialog) {\n  let {\n    x,\n    y\n  } = state.player;\n  const gridWidth = 100;\n  const gridHeight = 200;\n  switch (key) {\n    case 'ArrowUp':\n      if (y < gridHeight - 1) y++;\n      break;\n    case 'ArrowDown':\n      if (y > 0) y--;\n      break;\n    case 'ArrowLeft':\n      if (x > 0) x--;\n      break;\n    case 'ArrowRight':\n      if (x < gridWidth - 1) x++;\n      break;\n    default:\n      return;\n  }\n  const playerMoved = x !== state.player.x || y !== state.player.y;\n  if (playerMoved) {\n    dispatch({\n      type: 'UPDATE_PLAYER_POSITION',\n      payload: {\n        x,\n        y\n      }\n    });\n    checkEncounters(state, dispatch, showDialog);\n  }\n}\nfunction checkEncounters(state, dispatch, showDialog) {\n  var _state$greatPowers$, _state$greatPowers$2;\n  const playerPixelX = state.player.x * 40; // tileSize 40px from gameState.js\n  const playerPixelY = state.player.y * 40;\n  const activeMonsters = state.activeMonsters.filter(m => m.active && m.hp > 0);\n\n  // Check Watcher encounter (simplified)\n  if (Math.abs(playerPixelX - (((_state$greatPowers$ = state.greatPowers[0]) === null || _state$greatPowers$ === void 0 ? void 0 : _state$greatPowers$.x) || 0) * 40) < 160 &&\n  // Watcher's width in pixels\n  Math.abs(playerPixelY - (((_state$greatPowers$2 = state.greatPowers[0]) === null || _state$greatPowers$2 === void 0 ? void 0 : _state$greatPowers$2.y) || 0) * 40) < 160) {\n    // Height\n    showDialog(text.watcherDeathMessage, 10000);\n    setTimeout(() => {\n      dispatch({\n        type: 'UPDATE_PLAYER_HP',\n        payload: {\n          hp: 100\n        } // Reset HP\n      });\n      dispatch({\n        type: 'UPDATE_PLAYER_POSITION',\n        payload: {\n          x: state.redoubt.x,\n          y: state.redoubt.y\n        }\n      });\n      showDialog(text.deathReviveMessage, 3600);\n    }, 10800);\n    return;\n  }\n\n  // Check Abhuman encounter\n  for (const monster of activeMonsters) {\n    if (Math.abs(playerPixelX - monster.x * 40) <= 40 &&\n    // tileSize\n    Math.abs(playerPixelY - monster.y * 40) <= 40 && !state.inCombat) {\n      handleCombatStart(state, dispatch, showDialog);\n      break;\n    }\n  }\n\n  // Spawn monsters periodically (simplified from original)\n  if (state.moveCount % (state.spawnThreshold || 7) === 0) {\n    spawnMonsterNearPlayer(state, dispatch);\n    dispatch({\n      type: 'UPDATE_MOVE_COUNT',\n      payload: {\n        moveCount: 0\n      }\n    });\n    dispatch({\n      type: 'UPDATE_SPAWN_THRESHOLD',\n      payload: {\n        spawnThreshold: Math.floor(Math.random() * 7) + 4\n      }\n    });\n  } else {\n    dispatch({\n      type: 'UPDATE_MOVE_COUNT',\n      payload: {\n        moveCount: (state.moveCount || 0) + 1\n      }\n    });\n  }\n}\nfunction handleCombatStart(state, dispatch, showDialog) {\n  const attackers = state.activeMonsters.slice(0, state.maxAttackers).map((monster, i) => ({\n    monster,\n    position: {\n      x: state.player.x + (i % 2 ? 1 : -1),\n      y: state.player.y + (i < 2 ? -1 : 1)\n    }\n  }));\n  const dialogData = updateCombatDialogs(text.combatStartPlayerComment, attackers.map(() => text.combatStartEnemyComment), state.player, attackers.map(slot => slot.monster));\n  dispatch({\n    type: 'SET_COMBAT',\n    payload: {\n      inCombat: true,\n      attackSlots: attackers,\n      turnOrder: [state.player, ...attackers.map(slot => slot.monster)],\n      combatTurn: state.player,\n      dialogData: dialogData\n    }\n  });\n}\nexport function handleCombatStep(state, dispatch, showDialog) {\n  if (!state.inCombat || !state.turnOrder.length) return;\n  const current = state.combatTurn;\n  const currentIndex = state.turnOrder.indexOf(current);\n  const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n  let allMonsters = state.attackSlots.map(slot => slot.monster);\n  console.log('Combat Step - Current:', current === null || current === void 0 ? void 0 : current.name, 'Turn Order:', state.turnOrder.map(t => t.name), 'Active Monsters:', activeMonsters.map(m => `${m.name} HP:${m.hp}`));\n  let playerComment = \"\";\n  let enemyComments = allMonsters.map(() => \"\");\n  let updatedPlayer = {\n    ...state.player\n  };\n  let updatedAttackSlots = [...state.attackSlots];\n  if (current.name === state.player.name) {\n    const target = activeMonsters[0];\n    if (target) {\n      if (Math.random() < 0.8) {\n        target.hp -= 6;\n        playerComment = text.combatPlayerHitComment;\n        enemyComments[0] = target.hp <= 0 ? text.combatVictoryEnemyComment : \"\";\n      } else {\n        playerComment = text.combatPlayerMissComment;\n      }\n    }\n  } else if (activeMonsters.includes(current)) {\n    const monsterIndex = allMonsters.indexOf(current);\n    if (Math.random() < 0.5) {\n      updatedPlayer.hp -= 4;\n      enemyComments[monsterIndex] = text.combatEnemyHitComment;\n      allMonsters[monsterIndex].lastComment = text.combatEnemyHitComment;\n    } else {\n      enemyComments[monsterIndex] = text.combatEnemyMissComment;\n      allMonsters[monsterIndex].lastComment = text.combatEnemyMissComment;\n    }\n  }\n  const dialogData = updateCombatDialogs(playerComment, enemyComments, updatedPlayer, allMonsters);\n  const nextTurnIndex = (currentIndex + 1) % state.turnOrder.length;\n  const nextTurn = state.turnOrder[nextTurnIndex];\n  if (updatedPlayer.hp <= 0) {\n    endCombat(state, dispatch, showDialog);\n  } else if (activeMonsters.length === 0) {\n    endCombat(state, dispatch, showDialog);\n  } else {\n    if (current === state.turnOrder[state.turnOrder.length - 1]) {\n      resolveRound(state, dispatch);\n      updatedAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n      calculateTurnOrder(state, dispatch);\n      roundNumber++;\n    }\n    dispatch({\n      type: 'SET_COMBAT',\n      payload: {\n        inCombat: true,\n        attackSlots: updatedAttackSlots,\n        turnOrder: state.turnOrder,\n        combatTurn: nextTurn,\n        player: {\n          ...updatedPlayer,\n          lastComment: playerComment\n        },\n        dialogData: dialogData\n      }\n    });\n    console.log('After Dispatch - inCombat:', state.inCombat, 'Next Turn:', nextTurn === null || nextTurn === void 0 ? void 0 : nextTurn.name);\n  }\n}\nfunction calculateTurnOrder(state, dispatch) {\n  const combatants = [state.player, ...state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0)];\n  const newTurnOrder = combatants.filter(c => c.hp > 0);\n  dispatch({\n    type: 'SET_COMBAT',\n    payload: {\n      inCombat: state.inCombat,\n      attackSlots: state.attackSlots,\n      turnOrder: newTurnOrder,\n      combatTurn: newTurnOrder[0],\n      player: state.player,\n      dialogData: state.dialogData\n    }\n  });\n}\nfunction resolveRound(state, dispatch) {\n  const deadMonsters = state.attackSlots.filter(slot => slot.monster && slot.monster.hp <= 0);\n  if (deadMonsters.length > 0) {\n    deadMonsters.forEach(slot => {\n      slot.monster.active = false;\n      if (state.waitingMonsters.length > 0) {\n        const nextMonster = state.waitingMonsters.shift();\n        nextMonster.x = slot.position.x;\n        nextMonster.y = slot.position.y;\n        slot.monster = nextMonster;\n      } else {\n        slot.monster = null;\n      }\n    });\n    const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n    dispatch({\n      type: 'SET_COMBAT',\n      payload: {\n        inCombat: true,\n        attackSlots: newAttackSlots,\n        dialogData: state.dialogData\n      }\n    });\n  }\n}\nfunction moveWaitingMonsters(state, dispatch) {\n  const activeMonsters = state.activeMonsters.filter(m => m.active && m.hp > 0);\n  const allAttackSlotsFull = state.attackSlots.length >= state.maxAttackers;\n  activeMonsters.forEach(monster => {\n    if (monster.hp > 0 && !state.attackSlots.some(slot => slot.monster === monster)) {\n      const dx = Math.abs(monster.x - state.player.x);\n      const dy = Math.abs(monster.y - state.player.y);\n      if (allAttackSlotsFull && (dx <= 2 || dy <= 2)) {\n        if (!state.waitingMonsters.includes(monster)) {\n          dispatch({\n            type: 'UPDATE_WAITING_MONSTERS',\n            payload: {\n              waitingMonsters: [...state.waitingMonsters, monster]\n            }\n          });\n        }\n      }\n    }\n  });\n}\nfunction endCombat(state, dispatch, showDialog) {\n  dispatch({\n    type: 'SET_COMBAT',\n    payload: {\n      inCombat: false,\n      attackSlots: [],\n      waitingMonsters: [],\n      turnOrder: [],\n      combatTurn: null,\n      player: {\n        ...state.player,\n        lastComment: \"\"\n      },\n      dialogData: updateCombatDialogs(\"\", [], state.player, [])\n    }\n  });\n  roundNumber = 1;\n  showDialog(text.combatVictoryPlayerComment, 3600); // Optional victory message\n}\nfunction spawnMonsterNearPlayer(state, dispatch) {\n  const monsterTemplate = state.monsters.find(m => m.name === 'Abhuman');\n  const spawnDistance = Math.ceil(Math.random() * 3) + 1;\n  const direction = Math.floor(Math.random() * 4);\n  const newMonster = {\n    ...monsterTemplate,\n    active: true\n  };\n  switch (direction) {\n    case 0:\n      // Up\n      newMonster.x = state.player.x;\n      newMonster.y = Math.max(0, state.player.y - spawnDistance);\n      break;\n    case 1:\n      // Down\n      newMonster.x = state.player.x;\n      newMonster.y = Math.min(199, state.player.y + spawnDistance); // 200-grid height - 1\n      break;\n    case 2:\n      // Left\n      newMonster.x = Math.max(0, state.player.x - spawnDistance);\n      newMonster.y = state.player.y;\n      break;\n    case 3:\n      // Right\n      newMonster.x = Math.min(99, state.player.x + spawnDistance); // 100-grid width - 1\n      newMonster.y = state.player.y;\n      break;\n  }\n  dispatch({\n    type: 'ADD_ACTIVE_MONSTER',\n    payload: {\n      monster: newMonster\n    }\n  });\n}\n\n// Reducer actions (new for state updates)\nexport function updateMoveCount(state, dispatch, count) {\n  dispatch({\n    type: 'UPDATE_MOVE_COUNT',\n    payload: {\n      moveCount: count\n    }\n  });\n}\nexport function updateSpawnThreshold(state, dispatch, threshold) {\n  dispatch({\n    type: 'UPDATE_SPAWN_THRESHOLD',\n    payload: {\n      spawnThreshold: threshold\n    }\n  });\n}","map":{"version":3,"names":["updateCombatDialogs","roundNumber","handleMovePlayer","state","dispatch","key","showDialog","x","y","player","gridWidth","gridHeight","playerMoved","type","payload","checkEncounters","_state$greatPowers$","_state$greatPowers$2","playerPixelX","playerPixelY","activeMonsters","filter","m","active","hp","Math","abs","greatPowers","text","watcherDeathMessage","setTimeout","redoubt","deathReviveMessage","monster","inCombat","handleCombatStart","moveCount","spawnThreshold","spawnMonsterNearPlayer","floor","random","attackers","slice","maxAttackers","map","i","position","dialogData","combatStartPlayerComment","combatStartEnemyComment","slot","attackSlots","turnOrder","combatTurn","handleCombatStep","length","current","currentIndex","indexOf","allMonsters","console","log","name","t","playerComment","enemyComments","updatedPlayer","updatedAttackSlots","target","combatPlayerHitComment","combatVictoryEnemyComment","combatPlayerMissComment","includes","monsterIndex","combatEnemyHitComment","lastComment","combatEnemyMissComment","nextTurnIndex","nextTurn","endCombat","resolveRound","s","calculateTurnOrder","combatants","newTurnOrder","c","deadMonsters","forEach","waitingMonsters","nextMonster","shift","newAttackSlots","moveWaitingMonsters","allAttackSlotsFull","some","dx","dy","combatVictoryPlayerComment","monsterTemplate","monsters","find","spawnDistance","ceil","direction","newMonster","max","min","updateMoveCount","count","updateSpawnThreshold","threshold"],"sources":["/mnt/devplex/Nightland/nightland/src/modules/gameLoop.js"],"sourcesContent":["// nightland/src/modules/gameLoop.js\nimport { updateCombatDialogs } from './utils';\n\nlet roundNumber = 1; // From combat.js, moved here for now\n\nexport function handleMovePlayer(state, dispatch, key, showDialog) {\n    let { x, y } = state.player;\n    const gridWidth = 100;\n    const gridHeight = 200;\n\n    switch (key) {\n        case 'ArrowUp':\n            if (y < gridHeight - 1) y++;\n            break;\n        case 'ArrowDown':\n            if (y > 0) y--;\n            break;\n        case 'ArrowLeft':\n            if (x > 0) x--;\n            break;\n        case 'ArrowRight':\n            if (x < gridWidth - 1) x++;\n            break;\n        default:\n            return;\n    }\n\n    const playerMoved = x !== state.player.x || y !== state.player.y;\n    if (playerMoved) {\n        dispatch({\n            type: 'UPDATE_PLAYER_POSITION',\n            payload: { x, y }\n        });\n        checkEncounters(state, dispatch, showDialog);\n    }\n}\n\nfunction checkEncounters(state, dispatch, showDialog) {\n    const playerPixelX = state.player.x * 40; // tileSize 40px from gameState.js\n    const playerPixelY = state.player.y * 40;\n    const activeMonsters = state.activeMonsters.filter(m => m.active && m.hp > 0);\n\n    // Check Watcher encounter (simplified)\n    if (Math.abs(playerPixelX - (state.greatPowers[0]?.x || 0) * 40) < 160 && // Watcher's width in pixels\n        Math.abs(playerPixelY - (state.greatPowers[0]?.y || 0) * 40) < 160) { // Height\n        showDialog(text.watcherDeathMessage, 10000);\n        setTimeout(() => {\n            dispatch({\n                type: 'UPDATE_PLAYER_HP',\n                payload: { hp: 100 } // Reset HP\n            });\n            dispatch({\n                type: 'UPDATE_PLAYER_POSITION',\n                payload: { x: state.redoubt.x, y: state.redoubt.y }\n            });\n            showDialog(text.deathReviveMessage, 3600);\n        }, 10800);\n        return;\n    }\n\n    // Check Abhuman encounter\n    for (const monster of activeMonsters) {\n        if (Math.abs(playerPixelX - monster.x * 40) <= 40 && // tileSize\n            Math.abs(playerPixelY - monster.y * 40) <= 40 && !state.inCombat) {\n            handleCombatStart(state, dispatch, showDialog);\n            break;\n        }\n    }\n\n    // Spawn monsters periodically (simplified from original)\n    if (state.moveCount % (state.spawnThreshold || 7) === 0) {\n        spawnMonsterNearPlayer(state, dispatch);\n        dispatch({\n            type: 'UPDATE_MOVE_COUNT',\n            payload: { moveCount: 0 }\n        });\n        dispatch({\n            type: 'UPDATE_SPAWN_THRESHOLD',\n            payload: { spawnThreshold: Math.floor(Math.random() * 7) + 4 }\n        });\n    } else {\n        dispatch({\n            type: 'UPDATE_MOVE_COUNT',\n            payload: { moveCount: (state.moveCount || 0) + 1 }\n        });\n    }\n}\n\nfunction handleCombatStart(state, dispatch, showDialog) {\n    const attackers = state.activeMonsters.slice(0, state.maxAttackers).map((monster, i) => ({\n        monster,\n        position: { x: state.player.x + (i % 2 ? 1 : -1), y: state.player.y + (i < 2 ? -1 : 1) }\n    }));\n    const dialogData = updateCombatDialogs(\n        text.combatStartPlayerComment,\n        attackers.map(() => text.combatStartEnemyComment),\n        state.player,\n        attackers.map(slot => slot.monster)\n    );\n    dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n            inCombat: true,\n            attackSlots: attackers,\n            turnOrder: [state.player, ...attackers.map(slot => slot.monster)],\n            combatTurn: state.player,\n            dialogData: dialogData\n        }\n    });\n}\n\nexport function handleCombatStep(state, dispatch, showDialog) {\n    if (!state.inCombat || !state.turnOrder.length) return;\n\n    const current = state.combatTurn;\n    const currentIndex = state.turnOrder.indexOf(current);\n    const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n    let allMonsters = state.attackSlots.map(slot => slot.monster);\n\n    console.log('Combat Step - Current:', current?.name, 'Turn Order:', state.turnOrder.map(t => t.name), 'Active Monsters:', activeMonsters.map(m => `${m.name} HP:${m.hp}`));\n\n    let playerComment = \"\";\n    let enemyComments = allMonsters.map(() => \"\");\n    let updatedPlayer = { ...state.player };\n    let updatedAttackSlots = [...state.attackSlots];\n\n    if (current.name === state.player.name) {\n        const target = activeMonsters[0];\n        if (target) {\n            if (Math.random() < 0.8) {\n                target.hp -= 6;\n                playerComment = text.combatPlayerHitComment;\n                enemyComments[0] = target.hp <= 0 ? text.combatVictoryEnemyComment : \"\";\n            } else {\n                playerComment = text.combatPlayerMissComment;\n            }\n        }\n    } else if (activeMonsters.includes(current)) {\n        const monsterIndex = allMonsters.indexOf(current);\n        if (Math.random() < 0.5) {\n            updatedPlayer.hp -= 4;\n            enemyComments[monsterIndex] = text.combatEnemyHitComment;\n            allMonsters[monsterIndex].lastComment = text.combatEnemyHitComment;\n        } else {\n            enemyComments[monsterIndex] = text.combatEnemyMissComment;\n            allMonsters[monsterIndex].lastComment = text.combatEnemyMissComment;\n        }\n    }\n\n    const dialogData = updateCombatDialogs(playerComment, enemyComments, updatedPlayer, allMonsters);\n\n    const nextTurnIndex = (currentIndex + 1) % state.turnOrder.length;\n    const nextTurn = state.turnOrder[nextTurnIndex];\n\n    if (updatedPlayer.hp <= 0) {\n        endCombat(state, dispatch, showDialog);\n    } else if (activeMonsters.length === 0) {\n        endCombat(state, dispatch, showDialog);\n    } else {\n        if (current === state.turnOrder[state.turnOrder.length - 1]) {\n            resolveRound(state, dispatch);\n            updatedAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n            calculateTurnOrder(state, dispatch);\n            roundNumber++;\n        }\n\n        dispatch({\n            type: 'SET_COMBAT',\n            payload: {\n                inCombat: true,\n                attackSlots: updatedAttackSlots,\n                turnOrder: state.turnOrder,\n                combatTurn: nextTurn,\n                player: { ...updatedPlayer, lastComment: playerComment },\n                dialogData: dialogData\n            }\n        });\n        console.log('After Dispatch - inCombat:', state.inCombat, 'Next Turn:', nextTurn?.name);\n    }\n}\n\nfunction calculateTurnOrder(state, dispatch) {\n    const combatants = [state.player, ...state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0)];\n    const newTurnOrder = combatants.filter(c => c.hp > 0);\n    dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n            inCombat: state.inCombat,\n            attackSlots: state.attackSlots,\n            turnOrder: newTurnOrder,\n            combatTurn: newTurnOrder[0],\n            player: state.player,\n            dialogData: state.dialogData\n        }\n    });\n}\n\nfunction resolveRound(state, dispatch) {\n    const deadMonsters = state.attackSlots.filter(slot => slot.monster && slot.monster.hp <= 0);\n    if (deadMonsters.length > 0) {\n        deadMonsters.forEach(slot => {\n            slot.monster.active = false;\n            if (state.waitingMonsters.length > 0) {\n                const nextMonster = state.waitingMonsters.shift();\n                nextMonster.x = slot.position.x;\n                nextMonster.y = slot.position.y;\n                slot.monster = nextMonster;\n            } else {\n                slot.monster = null;\n            }\n        });\n        const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n        dispatch({\n            type: 'SET_COMBAT',\n            payload: {\n                inCombat: true,\n                attackSlots: newAttackSlots,\n                dialogData: state.dialogData\n            }\n        });\n    }\n}\n\nfunction moveWaitingMonsters(state, dispatch) {\n    const activeMonsters = state.activeMonsters.filter(m => m.active && m.hp > 0);\n    const allAttackSlotsFull = state.attackSlots.length >= state.maxAttackers;\n    activeMonsters.forEach(monster => {\n        if (monster.hp > 0 && !state.attackSlots.some(slot => slot.monster === monster)) {\n            const dx = Math.abs(monster.x - state.player.x);\n            const dy = Math.abs(monster.y - state.player.y);\n            if (allAttackSlotsFull && (dx <= 2 || dy <= 2)) {\n                if (!state.waitingMonsters.includes(monster)) {\n                    dispatch({\n                        type: 'UPDATE_WAITING_MONSTERS',\n                        payload: { waitingMonsters: [...state.waitingMonsters, monster] }\n                    });\n                }\n            }\n        }\n    });\n}\n\nfunction endCombat(state, dispatch, showDialog) {\n    dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n            inCombat: false,\n            attackSlots: [],\n            waitingMonsters: [],\n            turnOrder: [],\n            combatTurn: null,\n            player: { ...state.player, lastComment: \"\" },\n            dialogData: updateCombatDialogs(\"\", [], state.player, [])\n        }\n    });\n    roundNumber = 1;\n    showDialog(text.combatVictoryPlayerComment, 3600); // Optional victory message\n}\n\nfunction spawnMonsterNearPlayer(state, dispatch) {\n    const monsterTemplate = state.monsters.find(m => m.name === 'Abhuman');\n    const spawnDistance = Math.ceil(Math.random() * 3) + 1;\n    const direction = Math.floor(Math.random() * 4);\n    const newMonster = { ...monsterTemplate, active: true };\n    switch (direction) {\n        case 0: // Up\n            newMonster.x = state.player.x;\n            newMonster.y = Math.max(0, state.player.y - spawnDistance);\n            break;\n        case 1: // Down\n            newMonster.x = state.player.x;\n            newMonster.y = Math.min(199, state.player.y + spawnDistance); // 200-grid height - 1\n            break;\n        case 2: // Left\n            newMonster.x = Math.max(0, state.player.x - spawnDistance);\n            newMonster.y = state.player.y;\n            break;\n        case 3: // Right\n            newMonster.x = Math.min(99, state.player.x + spawnDistance); // 100-grid width - 1\n            newMonster.y = state.player.y;\n            break;\n    }\n    dispatch({\n        type: 'ADD_ACTIVE_MONSTER',\n        payload: { monster: newMonster }\n    });\n}\n\n// Reducer actions (new for state updates)\nexport function updateMoveCount(state, dispatch, count) {\n    dispatch({ type: 'UPDATE_MOVE_COUNT', payload: { moveCount: count } });\n}\n\nexport function updateSpawnThreshold(state, dispatch, threshold) {\n    dispatch({ type: 'UPDATE_SPAWN_THRESHOLD', payload: { spawnThreshold: threshold } });\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}