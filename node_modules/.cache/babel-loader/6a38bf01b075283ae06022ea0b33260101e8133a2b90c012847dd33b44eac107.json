{"ast":null,"code":"// nightland/src/modules/combat.js\nimport { updateCombatDialogs } from './utils';\nexport let roundNumber = 1;\nexport function calculateTurnOrder(state, dispatch) {\n  const combatants = [state.player, ...state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0)];\n  const newTurnOrder = combatants.filter(c => c.hp > 0);\n  dispatch({\n    type: 'SET_COMBAT',\n    payload: {\n      inCombat: state.inCombat,\n      attackSlots: state.attackSlots,\n      turnOrder: newTurnOrder,\n      combatTurn: newTurnOrder[0],\n      player: state.player,\n      dialogData: state.dialogData\n    }\n  });\n}\nexport function resolveRound(state, dispatch) {\n  const deadMonsters = state.attackSlots.filter(slot => slot.monster && slot.monster.hp <= 0);\n  if (deadMonsters.length > 0) {\n    deadMonsters.forEach(slot => {\n      slot.monster.active = false;\n      if (state.waitingMonsters.length > 0) {\n        const nextMonster = state.waitingMonsters.shift();\n        nextMonster.x = slot.position.x;\n        nextMonster.y = slot.position.y;\n        slot.monster = nextMonster;\n      } else {\n        slot.monster = null;\n      }\n    });\n    const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n    dispatch({\n      type: 'SET_COMBAT',\n      payload: {\n        inCombat: true,\n        attackSlots: newAttackSlots,\n        dialogData: state.dialogData\n      }\n    });\n  }\n}\nexport function moveWaitingMonsters(state, dispatch) {\n  const activeMonsters = state.activeMonsters.filter(m => m.active && m.hp > 0);\n  const allAttackSlotsFull = state.attackSlots.length >= state.maxAttackers;\n  activeMonsters.forEach(monster => {\n    if (monster.hp > 0 && !state.attackSlots.some(slot => slot.monster === monster)) {\n      const dx = Math.abs(monster.x - state.player.x);\n      const dy = Math.abs(monster.y - state.player.y);\n      if (allAttackSlotsFull && (dx <= 2 || dy <= 2)) {\n        if (!state.waitingMonsters.includes(monster)) {\n          dispatch({\n            type: 'UPDATE_WAITING_MONSTERS',\n            payload: {\n              waitingMonsters: [...state.waitingMonsters, monster]\n            }\n          });\n        }\n      }\n    }\n  });\n}\nexport function endCombat(state, dispatch) {\n  dispatch({\n    type: 'SET_COMBAT',\n    payload: {\n      inCombat: false,\n      attackSlots: [],\n      waitingMonsters: [],\n      turnOrder: [],\n      combatTurn: null,\n      player: {\n        ...state.player,\n        lastComment: \"\"\n      },\n      dialogData: updateCombatDialogs(\"\", [], state.player, [])\n    }\n  });\n  roundNumber = 1;\n}\nexport function combatStep(state, dispatch) {\n  if (!state.inCombat || !state.turnOrder.length) return;\n  const current = state.combatTurn;\n  const currentIndex = state.turnOrder.indexOf(current);\n  const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n  let allMonsters = state.attackSlots.map(slot => slot.monster);\n  console.log('Combat Step - Current:', current === null || current === void 0 ? void 0 : current.name, 'Turn Order:', state.turnOrder.map(t => t.name), 'Active Monsters:', activeMonsters.map(m => `${m.name} HP:${m.hp}`));\n  let playerComment = \"\";\n  let enemyComments = allMonsters.map(() => \"\");\n  let updatedPlayer = {\n    ...state.player\n  };\n  let updatedAttackSlots = [...state.attackSlots];\n  console.log('Player Check - Current.name === state.player.name:', current.name === state.player.name, 'Current:', current, 'State.Player:', state.player);\n  if (current.name === state.player.name) {\n    const target = activeMonsters[0];\n    console.log('Player Turn - Target:', target ? `${target.name} HP:${target.hp}` : 'None');\n    console.log('Active Monsters:', activeMonsters.map(m => `${m.name} HP:${m.hp}`));\n    if (target) {\n      if (Math.random() < 0.8) {\n        target.hp -= 6;\n        playerComment = \"You hit for 6 points!\";\n        enemyComments[0] = target.hp <= 0 ? \"Monster is dead!\" : \"\";\n        console.log('Player Hit - New Monster HP:', target.hp);\n      } else {\n        playerComment = \"You miss!\";\n        console.log('Player Missed');\n      }\n    } else {\n      playerComment = \"No target available!\";\n      console.log('No Target Available');\n    }\n  } else if (activeMonsters.includes(current)) {\n    const monsterIndex = allMonsters.indexOf(current);\n    if (Math.random() < 0.5) {\n      updatedPlayer.hp -= 4;\n      enemyComments[monsterIndex] = \"He hit you for 4 points!\";\n      allMonsters[monsterIndex].lastComment = \"He hit you for 4 points!\";\n    } else {\n      enemyComments[monsterIndex] = \"He missed you!\";\n      allMonsters[monsterIndex].lastComment = \"He missed you!\";\n    }\n  }\n  const dialogData = updateCombatDialogs(playerComment, enemyComments, updatedPlayer, allMonsters);\n  console.log('Combat Step - Player Comment Before Update:', playerComment);\n  console.log('Combat Step - Setting Dialog Data:', dialogData);\n  const nextTurnIndex = (currentIndex + 1) % state.turnOrder.length;\n  const nextTurn = state.turnOrder[nextTurnIndex];\n  if (updatedPlayer.hp <= 0) {\n    endCombat(state, dispatch);\n  } else if (activeMonsters.length === 0 && state.waitingMonsters.length === 0) {\n    endCombat(state, dispatch);\n  } else {\n    if (current === state.turnOrder[state.turnOrder.length - 1]) {\n      resolveRound(state, dispatch);\n      updatedAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n      calculateTurnOrder(state, dispatch);\n      roundNumber++;\n    }\n    dispatch({\n      type: 'SET_COMBAT',\n      payload: {\n        inCombat: true,\n        attackSlots: updatedAttackSlots,\n        turnOrder: state.turnOrder,\n        combatTurn: nextTurn,\n        player: {\n          ...updatedPlayer,\n          lastComment: playerComment\n        },\n        dialogData: dialogData\n      }\n    });\n    console.log('After Dispatch - inCombat:', state.inCombat, 'Next Turn:', nextTurn === null || nextTurn === void 0 ? void 0 : nextTurn.name);\n    moveWaitingMonsters(state, dispatch);\n  }\n}","map":{"version":3,"names":["updateCombatDialogs","roundNumber","calculateTurnOrder","state","dispatch","combatants","player","attackSlots","map","slot","monster","filter","m","hp","newTurnOrder","c","type","payload","inCombat","turnOrder","combatTurn","dialogData","resolveRound","deadMonsters","length","forEach","active","waitingMonsters","nextMonster","shift","x","position","y","newAttackSlots","s","moveWaitingMonsters","activeMonsters","allAttackSlotsFull","maxAttackers","some","dx","Math","abs","dy","includes","endCombat","lastComment","combatStep","current","currentIndex","indexOf","allMonsters","console","log","name","t","playerComment","enemyComments","updatedPlayer","updatedAttackSlots","target","random","monsterIndex","nextTurnIndex","nextTurn"],"sources":["/mnt/devplex/Nightland/nightland/src/modules/combat.js"],"sourcesContent":["// nightland/src/modules/combat.js\nimport { updateCombatDialogs } from './utils';\n\nexport let roundNumber = 1;\n\nexport function calculateTurnOrder(state, dispatch) {\n    const combatants = [state.player, ...state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0)];\n    const newTurnOrder = combatants.filter(c => c.hp > 0);\n    dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n            inCombat: state.inCombat,\n            attackSlots: state.attackSlots,\n            turnOrder: newTurnOrder,\n            combatTurn: newTurnOrder[0],\n            player: state.player,\n            dialogData: state.dialogData\n        }\n    });\n}\n\nexport function resolveRound(state, dispatch) {\n    const deadMonsters = state.attackSlots.filter(slot => slot.monster && slot.monster.hp <= 0);\n    if (deadMonsters.length > 0) {\n        deadMonsters.forEach(slot => {\n            slot.monster.active = false;\n            if (state.waitingMonsters.length > 0) {\n                const nextMonster = state.waitingMonsters.shift();\n                nextMonster.x = slot.position.x;\n                nextMonster.y = slot.position.y;\n                slot.monster = nextMonster;\n            } else {\n                slot.monster = null;\n            }\n        });\n        const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n        dispatch({\n            type: 'SET_COMBAT',\n            payload: {\n                inCombat: true,\n                attackSlots: newAttackSlots,\n                dialogData: state.dialogData\n            }\n        });\n    }\n}\n\nexport function moveWaitingMonsters(state, dispatch) {\n    const activeMonsters = state.activeMonsters.filter(m => m.active && m.hp > 0);\n    const allAttackSlotsFull = state.attackSlots.length >= state.maxAttackers;\n    activeMonsters.forEach(monster => {\n        if (monster.hp > 0 && !state.attackSlots.some(slot => slot.monster === monster)) {\n            const dx = Math.abs(monster.x - state.player.x);\n            const dy = Math.abs(monster.y - state.player.y);\n            if (allAttackSlotsFull && (dx <= 2 || dy <= 2)) {\n                if (!state.waitingMonsters.includes(monster)) {\n                    dispatch({\n                        type: 'UPDATE_WAITING_MONSTERS',\n                        payload: { waitingMonsters: [...state.waitingMonsters, monster] }\n                    });\n                }\n            }\n        }\n    });\n}\n\nexport function endCombat(state, dispatch) {\n    dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n            inCombat: false,\n            attackSlots: [],\n            waitingMonsters: [],\n            turnOrder: [],\n            combatTurn: null,\n            player: { ...state.player, lastComment: \"\" },\n            dialogData: updateCombatDialogs(\"\", [], state.player, [])\n        }\n    });\n    roundNumber = 1;\n}\n\nexport function combatStep(state, dispatch) {\n    if (!state.inCombat || !state.turnOrder.length) return;\n\n    const current = state.combatTurn;\n    const currentIndex = state.turnOrder.indexOf(current);\n    const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n    let allMonsters = state.attackSlots.map(slot => slot.monster);\n\n    console.log('Combat Step - Current:', current?.name, 'Turn Order:', state.turnOrder.map(t => t.name), 'Active Monsters:', activeMonsters.map(m => `${m.name} HP:${m.hp}`));\n\n    let playerComment = \"\";\n    let enemyComments = allMonsters.map(() => \"\");\n    let updatedPlayer = { ...state.player };\n    let updatedAttackSlots = [...state.attackSlots];\n\n    console.log('Player Check - Current.name === state.player.name:', current.name === state.player.name, 'Current:', current, 'State.Player:', state.player);\n\n    if (current.name === state.player.name) {\n        const target = activeMonsters[0];\n        console.log('Player Turn - Target:', target ? `${target.name} HP:${target.hp}` : 'None');\n        console.log('Active Monsters:', activeMonsters.map(m => `${m.name} HP:${m.hp}`));\n        if (target) {\n            if (Math.random() < 0.8) {\n                target.hp -= 6;\n                playerComment = \"You hit for 6 points!\";\n                enemyComments[0] = target.hp <= 0 ? \"Monster is dead!\" : \"\";\n                console.log('Player Hit - New Monster HP:', target.hp);\n            } else {\n                playerComment = \"You miss!\";\n                console.log('Player Missed');\n            }\n        } else {\n            playerComment = \"No target available!\";\n            console.log('No Target Available');\n        }\n    } else if (activeMonsters.includes(current)) {\n        const monsterIndex = allMonsters.indexOf(current);\n        if (Math.random() < 0.5) {\n            updatedPlayer.hp -= 4;\n            enemyComments[monsterIndex] = \"He hit you for 4 points!\";\n            allMonsters[monsterIndex].lastComment = \"He hit you for 4 points!\";\n        } else {\n            enemyComments[monsterIndex] = \"He missed you!\";\n            allMonsters[monsterIndex].lastComment = \"He missed you!\";\n        }\n    }\n\n    const dialogData = updateCombatDialogs(playerComment, enemyComments, updatedPlayer, allMonsters);\n    console.log('Combat Step - Player Comment Before Update:', playerComment);\n    console.log('Combat Step - Setting Dialog Data:', dialogData);\n\n    const nextTurnIndex = (currentIndex + 1) % state.turnOrder.length;\n    const nextTurn = state.turnOrder[nextTurnIndex];\n\n    if (updatedPlayer.hp <= 0) {\n        endCombat(state, dispatch);\n    } else if (activeMonsters.length === 0 && state.waitingMonsters.length === 0) {\n        endCombat(state, dispatch);\n    } else {\n        if (current === state.turnOrder[state.turnOrder.length - 1]) {\n            resolveRound(state, dispatch);\n            updatedAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n            calculateTurnOrder(state, dispatch);\n            roundNumber++;\n        }\n\n        dispatch({\n            type: 'SET_COMBAT',\n            payload: {\n                inCombat: true,\n                attackSlots: updatedAttackSlots,\n                turnOrder: state.turnOrder,\n                combatTurn: nextTurn,\n                player: { ...updatedPlayer, lastComment: playerComment },\n                dialogData: dialogData\n            }\n        });\n        console.log('After Dispatch - inCombat:', state.inCombat, 'Next Turn:', nextTurn?.name);\n        moveWaitingMonsters(state, dispatch);\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}