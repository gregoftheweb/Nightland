{"ast":null,"code":"var _jsxFileName = \"/mnt/devplex/Nightland/nightland/src/components/Combat.js\",\n  _s = $RefreshSig$();\n// nightland/src/components/Combat.js\nimport React, { useEffect, useState } from 'react';\nimport Dialog from './Dialog';\nimport { updateCombatDialogs } from '../modules/utils'; // Adjust path as needed\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction calculateTurnOrder(state, dispatch) {\n  const combatants = [state.player, ...state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0)];\n  const newTurnOrder = combatants.filter(c => c.hp > 0);\n  dispatch({\n    type: 'SET_COMBAT',\n    payload: {\n      inCombat: state.inCombat,\n      attackSlots: state.attackSlots,\n      turnOrder: newTurnOrder,\n      combatTurn: newTurnOrder[0],\n      dialogData: state.dialogData // Preserve existing dialogData\n    }\n  });\n}\nfunction resolveRound(state, dispatch) {\n  const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n  const deadMonsters = state.attackSlots.filter(slot => slot.monster && slot.monster.hp <= 0);\n  if (deadMonsters.length > 0) {\n    deadMonsters.forEach(slot => {\n      slot.monster.active = false;\n      if (state.waitingMonsters.length > 0) {\n        const nextMonster = state.waitingMonsters.shift();\n        nextMonster.x = slot.position.x;\n        nextMonster.y = slot.position.y;\n        slot.monster = nextMonster;\n      } else {\n        slot.monster = null;\n      }\n    });\n    const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n    dispatch({\n      type: 'SET_COMBAT',\n      payload: {\n        inCombat: true,\n        attackSlots: newAttackSlots,\n        dialogData: state.dialogData // Preserve\n      }\n    });\n  }\n  moveWaitingMonsters(state, dispatch);\n  calculateTurnOrder(state, dispatch);\n}\nfunction moveWaitingMonsters(state, dispatch) {\n  const activeMonsters = state.activeMonsters.filter(m => m.active && m.hp > 0);\n  const allAttackSlotsFull = state.attackSlots.length >= state.maxAttackers;\n  activeMonsters.forEach(monster => {\n    if (monster.hp > 0 && !state.attackSlots.some(slot => slot.monster === monster)) {\n      const dx = Math.abs(monster.x - state.player.x);\n      const dy = Math.abs(monster.y - state.player.y);\n      if (allAttackSlotsFull && (dx <= 2 || dy <= 2)) {\n        if (!state.waitingMonsters.includes(monster)) {\n          dispatch({\n            type: 'UPDATE_WAITING_MONSTERS',\n            payload: {\n              waitingMonsters: [...state.waitingMonsters, monster]\n            }\n          });\n        }\n      }\n    }\n  });\n}\nfunction endCombat(state, dispatch) {\n  dispatch({\n    type: 'SET_COMBAT',\n    payload: {\n      inCombat: false,\n      attackSlots: [],\n      waitingMonsters: [],\n      turnOrder: [],\n      combatTurn: null,\n      player: {\n        ...state.player,\n        lastComment: \"\"\n      },\n      dialogData: updateCombatDialogs(\"\", [], state.player, [])\n    }\n  });\n  roundNumber = 1;\n}\nlet roundNumber = 1;\nfunction combatStep(state, dispatch) {\n  var _state$dialogData, _state$dialogData$pla;\n  if (!state.inCombat || !state.turnOrder.length) return;\n  const current = state.combatTurn;\n  const currentIndex = state.turnOrder.indexOf(current);\n  const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n  let allMonsters = state.attackSlots.map(slot => slot.monster);\n  console.log('Combat Step - Current:', current === null || current === void 0 ? void 0 : current.name, 'Turn Order:', state.turnOrder.map(t => t.name), 'Active Monsters:', activeMonsters.map(m => m.name + ' HP:' + m.hp));\n  let playerComment = ((_state$dialogData = state.dialogData) === null || _state$dialogData === void 0 ? void 0 : (_state$dialogData$pla = _state$dialogData.player) === null || _state$dialogData$pla === void 0 ? void 0 : _state$dialogData$pla.comment) || \"\"; // Preserve previous comment unless updated\n  let enemyComments = allMonsters.map(() => \"\");\n  if (current === state.player) {\n    const target = activeMonsters[0];\n    console.log('Player Turn - Target:', target ? `${target.name} HP:${target.hp}` : 'None');\n    console.log('Active Monsters Check:', activeMonsters);\n    if (target) {\n      if (Math.random() < 0.8) {\n        const newHp = target.hp - 6;\n        target.hp = newHp;\n        playerComment = \"You hit for 6 points!\";\n        enemyComments[0] = target.hp <= 0 ? \"Monster is dead!\" : \"\";\n        if (target.hp <= 0) {\n          calculateTurnOrder(state, dispatch);\n        }\n      } else {\n        playerComment = \"You miss!\";\n      }\n    } else {\n      playerComment = \"No target available!\";\n    }\n  } else if (activeMonsters.includes(current)) {\n    const monsterIndex = allMonsters.indexOf(current);\n    const isFirstLivingMonster = currentIndex === 1 && allMonsters.some(m => m && m.hp <= 0);\n    if (isFirstLivingMonster) {\n      const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n      allMonsters = newAttackSlots.map(slot => slot.monster);\n      dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n          inCombat: true,\n          attackSlots: newAttackSlots,\n          dialogData: state.dialogData // Preserve\n        }\n      });\n      for (let i = 0; i < newAttackSlots.length; i++) {\n        console.log(`Flicker would apply to combat-enemy-${i + 1}`);\n      }\n    }\n    if (Math.random() < 0.5) {\n      const newHp = state.player.hp - 4;\n      enemyComments[monsterIndex] = \"He hit you for 4 points!\";\n      allMonsters[monsterIndex].lastComment = \"He hit you for 4 points!\";\n      dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n          inCombat: state.inCombat,\n          attackSlots: state.attackSlots,\n          turnOrder: state.turnOrder,\n          combatTurn: state.combatTurn,\n          player: {\n            ...state.player,\n            hp: newHp\n          },\n          dialogData: state.dialogData // Preserve\n        }\n      });\n    } else {\n      enemyComments[monsterIndex] = \"He missed you!\";\n      allMonsters[monsterIndex].lastComment = \"He missed you!\";\n    }\n  }\n  const dialogData = updateCombatDialogs(playerComment, enemyComments, state.player, allMonsters);\n  console.log('Combat Step - Player Comment Before Update:', playerComment);\n  console.log('Combat Step - Setting Dialog Data:', dialogData);\n  const nextTurnIndex = (currentIndex + 1) % state.turnOrder.length;\n  const nextTurn = state.turnOrder[nextTurnIndex];\n  if (state.player.hp <= 0) {\n    endCombat(state, dispatch);\n    dispatch({\n      type: 'SET_COMBAT',\n      payload: {\n        inCombat: false,\n        attackSlots: [],\n        waitingMonsters: [],\n        turnOrder: [],\n        combatTurn: null,\n        player: {\n          ...state.player,\n          lastComment: \"You have perished!\"\n        },\n        dialogData: updateCombatDialogs(\"You have perished!\", allMonsters.map(() => \"Victory over the human!\"), state.player, allMonsters)\n      }\n    });\n  } else if (activeMonsters.length === 0 && state.waitingMonsters.length === 0) {\n    endCombat(state, dispatch);\n    dispatch({\n      type: 'SET_COMBAT',\n      payload: {\n        inCombat: false,\n        attackSlots: [],\n        waitingMonsters: [],\n        turnOrder: [],\n        combatTurn: null,\n        player: {\n          ...state.player,\n          lastComment: \"Victory is yours!\"\n        },\n        dialogData: updateCombatDialogs(\"Victory is yours!\", [], state.player, [])\n      }\n    });\n  } else {\n    dispatch({\n      type: 'SET_COMBAT',\n      payload: {\n        inCombat: true,\n        attackSlots: state.attackSlots,\n        turnOrder: state.turnOrder,\n        combatTurn: nextTurn,\n        player: {\n          ...state.player,\n          lastComment: playerComment\n        },\n        dialogData: dialogData\n      }\n    });\n    console.log('After Dispatch - inCombat:', state.inCombat, 'Next Turn:', nextTurn === null || nextTurn === void 0 ? void 0 : nextTurn.name);\n    moveWaitingMonsters(state, dispatch);\n    if (current === state.turnOrder[state.turnOrder.length - 1]) {\n      resolveRound(state, dispatch);\n      calculateTurnOrder(state, dispatch);\n      roundNumber++;\n    }\n  }\n}\nconst Combat = ({\n  state,\n  dispatch\n}) => {\n  _s();\n  var _state$dialogData2, _state$dialogData3, _state$dialogData3$en, _state$dialogData4, _state$dialogData4$pl;\n  const [combatActive, setCombatActive] = useState(false);\n  useEffect(() => {\n    if (state.inCombat && !combatActive) {\n      var _state$combatTurn;\n      console.log('Combat Started - Initial State:', {\n        combatTurn: (_state$combatTurn = state.combatTurn) === null || _state$combatTurn === void 0 ? void 0 : _state$combatTurn.name,\n        attackSlots: state.attackSlots\n      });\n      setCombatActive(true);\n    }\n  }, [state.inCombat]);\n  const handleNextTurn = () => {\n    console.log('Next Turn Clicked');\n    combatStep(state, dispatch);\n  };\n  console.log('Combat Component - inCombat:', state.inCombat, 'Dialog Data:', state.dialogData);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"combat\",\n    children: [/*#__PURE__*/_jsxDEV(Dialog, {\n      data: ((_state$dialogData2 = state.dialogData) === null || _state$dialogData2 === void 0 ? void 0 : _state$dialogData2.player) || {\n        name: state.player.name,\n        hp: state.player.hp,\n        comment: ''\n      },\n      index: \"player\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 242,\n      columnNumber: 13\n    }, this), (_state$dialogData3 = state.dialogData) === null || _state$dialogData3 === void 0 ? void 0 : (_state$dialogData3$en = _state$dialogData3.enemies) === null || _state$dialogData3$en === void 0 ? void 0 : _state$dialogData3$en.map((enemy, i) => enemy && /*#__PURE__*/_jsxDEV(Dialog, {\n      data: enemy,\n      index: i\n    }, i, false, {\n      fileName: _jsxFileName,\n      lineNumber: 244,\n      columnNumber: 17\n    }, this)), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        color: 'red',\n        fontSize: '20px'\n      },\n      children: [\"Raw Player Comment: \", ((_state$dialogData4 = state.dialogData) === null || _state$dialogData4 === void 0 ? void 0 : (_state$dialogData4$pl = _state$dialogData4.player) === null || _state$dialogData4$pl === void 0 ? void 0 : _state$dialogData4$pl.comment) || 'No comment yet']\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 247,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleNextTurn,\n      children: \"Next Turn\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 250,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 241,\n    columnNumber: 9\n  }, this);\n};\n_s(Combat, \"wiBhgT2Tb9GuO9zZXnZimbCQPmI=\");\n_c = Combat;\nexport default Combat;\nvar _c;\n$RefreshReg$(_c, \"Combat\");","map":{"version":3,"names":["React","useEffect","useState","Dialog","updateCombatDialogs","jsxDEV","_jsxDEV","calculateTurnOrder","state","dispatch","combatants","player","attackSlots","map","slot","monster","filter","m","hp","newTurnOrder","c","type","payload","inCombat","turnOrder","combatTurn","dialogData","resolveRound","activeMonsters","deadMonsters","length","forEach","active","waitingMonsters","nextMonster","shift","x","position","y","newAttackSlots","s","moveWaitingMonsters","allAttackSlotsFull","maxAttackers","some","dx","Math","abs","dy","includes","endCombat","lastComment","roundNumber","combatStep","_state$dialogData","_state$dialogData$pla","current","currentIndex","indexOf","allMonsters","console","log","name","t","playerComment","comment","enemyComments","target","random","newHp","monsterIndex","isFirstLivingMonster","i","nextTurnIndex","nextTurn","Combat","_s","_state$dialogData2","_state$dialogData3","_state$dialogData3$en","_state$dialogData4","_state$dialogData4$pl","combatActive","setCombatActive","_state$combatTurn","handleNextTurn","className","children","data","index","fileName","_jsxFileName","lineNumber","columnNumber","enemies","enemy","style","color","fontSize","onClick","_c","$RefreshReg$"],"sources":["/mnt/devplex/Nightland/nightland/src/components/Combat.js"],"sourcesContent":["// nightland/src/components/Combat.js\nimport React, { useEffect, useState } from 'react';\nimport Dialog from './Dialog';\nimport { updateCombatDialogs } from '../modules/utils'; // Adjust path as needed\n\nfunction calculateTurnOrder(state, dispatch) {\n    const combatants = [state.player, ...state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0)];\n    const newTurnOrder = combatants.filter(c => c.hp > 0);\n    dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n            inCombat: state.inCombat,\n            attackSlots: state.attackSlots,\n            turnOrder: newTurnOrder,\n            combatTurn: newTurnOrder[0],\n            dialogData: state.dialogData // Preserve existing dialogData\n        }\n    });\n}\n\nfunction resolveRound(state, dispatch) {\n    const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n    const deadMonsters = state.attackSlots.filter(slot => slot.monster && slot.monster.hp <= 0);\n\n    if (deadMonsters.length > 0) {\n        deadMonsters.forEach(slot => {\n            slot.monster.active = false;\n            if (state.waitingMonsters.length > 0) {\n                const nextMonster = state.waitingMonsters.shift();\n                nextMonster.x = slot.position.x;\n                nextMonster.y = slot.position.y;\n                slot.monster = nextMonster;\n            } else {\n                slot.monster = null;\n            }\n        });\n        const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n        dispatch({\n            type: 'SET_COMBAT',\n            payload: {\n                inCombat: true,\n                attackSlots: newAttackSlots,\n                dialogData: state.dialogData // Preserve\n            }\n        });\n    }\n\n    moveWaitingMonsters(state, dispatch);\n    calculateTurnOrder(state, dispatch);\n}\n\nfunction moveWaitingMonsters(state, dispatch) {\n    const activeMonsters = state.activeMonsters.filter(m => m.active && m.hp > 0);\n    const allAttackSlotsFull = state.attackSlots.length >= state.maxAttackers;\n    activeMonsters.forEach(monster => {\n        if (monster.hp > 0 && !state.attackSlots.some(slot => slot.monster === monster)) {\n            const dx = Math.abs(monster.x - state.player.x);\n            const dy = Math.abs(monster.y - state.player.y);\n            if (allAttackSlotsFull && (dx <= 2 || dy <= 2)) {\n                if (!state.waitingMonsters.includes(monster)) {\n                    dispatch({\n                        type: 'UPDATE_WAITING_MONSTERS',\n                        payload: { waitingMonsters: [...state.waitingMonsters, monster] }\n                    });\n                }\n            }\n        }\n    });\n}\n\nfunction endCombat(state, dispatch) {\n    dispatch({\n        type: 'SET_COMBAT',\n        payload: {\n            inCombat: false,\n            attackSlots: [],\n            waitingMonsters: [],\n            turnOrder: [],\n            combatTurn: null,\n            player: { ...state.player, lastComment: \"\" },\n            dialogData: updateCombatDialogs(\"\", [], state.player, [])\n        }\n    });\n    roundNumber = 1;\n}\n\n\nlet roundNumber = 1;\n\n\nfunction combatStep(state, dispatch) {\n    if (!state.inCombat || !state.turnOrder.length) return;\n\n    const current = state.combatTurn;\n    const currentIndex = state.turnOrder.indexOf(current);\n    const activeMonsters = state.attackSlots.map(slot => slot.monster).filter(m => m && m.hp > 0);\n    let allMonsters = state.attackSlots.map(slot => slot.monster);\n\n    console.log('Combat Step - Current:', current?.name, 'Turn Order:', state.turnOrder.map(t => t.name), 'Active Monsters:', activeMonsters.map(m => m.name + ' HP:' + m.hp));\n\n    let playerComment = state.dialogData?.player?.comment || \"\"; // Preserve previous comment unless updated\n    let enemyComments = allMonsters.map(() => \"\");\n\n    if (current === state.player) {\n        const target = activeMonsters[0];\n        console.log('Player Turn - Target:', target ? `${target.name} HP:${target.hp}` : 'None');\n        console.log('Active Monsters Check:', activeMonsters);\n        if (target) {\n            if (Math.random() < 0.8) {\n                const newHp = target.hp - 6;\n                target.hp = newHp;\n                playerComment = \"You hit for 6 points!\";\n                enemyComments[0] = target.hp <= 0 ? \"Monster is dead!\" : \"\";\n                if (target.hp <= 0) {\n                    calculateTurnOrder(state, dispatch);\n                }\n            } else {\n                playerComment = \"You miss!\";\n            }\n        } else {\n            playerComment = \"No target available!\";\n        }\n    } else if (activeMonsters.includes(current)) {\n        const monsterIndex = allMonsters.indexOf(current);\n        const isFirstLivingMonster = currentIndex === 1 && allMonsters.some(m => m && m.hp <= 0);\n        if (isFirstLivingMonster) {\n            const newAttackSlots = state.attackSlots.filter(s => s.monster && s.monster.hp > 0);\n            allMonsters = newAttackSlots.map(slot => slot.monster);\n            dispatch({\n                type: 'SET_COMBAT',\n                payload: {\n                    inCombat: true,\n                    attackSlots: newAttackSlots,\n                    dialogData: state.dialogData // Preserve\n                }\n            });\n            for (let i = 0; i < newAttackSlots.length; i++) {\n                console.log(`Flicker would apply to combat-enemy-${i + 1}`);\n            }\n        }\n\n        if (Math.random() < 0.5) {\n            const newHp = state.player.hp - 4;\n            enemyComments[monsterIndex] = \"He hit you for 4 points!\";\n            allMonsters[monsterIndex].lastComment = \"He hit you for 4 points!\";\n            dispatch({\n                type: 'SET_COMBAT',\n                payload: {\n                    inCombat: state.inCombat,\n                    attackSlots: state.attackSlots,\n                    turnOrder: state.turnOrder,\n                    combatTurn: state.combatTurn,\n                    player: { ...state.player, hp: newHp },\n                    dialogData: state.dialogData // Preserve\n                }\n            });\n        } else {\n            enemyComments[monsterIndex] = \"He missed you!\";\n            allMonsters[monsterIndex].lastComment = \"He missed you!\";\n        }\n    }\n\n    const dialogData = updateCombatDialogs(playerComment, enemyComments, state.player, allMonsters);\n    console.log('Combat Step - Player Comment Before Update:', playerComment);\n    console.log('Combat Step - Setting Dialog Data:', dialogData);\n\n    const nextTurnIndex = (currentIndex + 1) % state.turnOrder.length;\n    const nextTurn = state.turnOrder[nextTurnIndex];\n\n    if (state.player.hp <= 0) {\n        endCombat(state, dispatch);\n        dispatch({\n            type: 'SET_COMBAT',\n            payload: {\n                inCombat: false,\n                attackSlots: [],\n                waitingMonsters: [],\n                turnOrder: [],\n                combatTurn: null,\n                player: { ...state.player, lastComment: \"You have perished!\" },\n                dialogData: updateCombatDialogs(\"You have perished!\", allMonsters.map(() => \"Victory over the human!\"), state.player, allMonsters)\n            }\n        });\n    } else if (activeMonsters.length === 0 && state.waitingMonsters.length === 0) {\n        endCombat(state, dispatch);\n        dispatch({\n            type: 'SET_COMBAT',\n            payload: {\n                inCombat: false,\n                attackSlots: [],\n                waitingMonsters: [],\n                turnOrder: [],\n                combatTurn: null,\n                player: { ...state.player, lastComment: \"Victory is yours!\" },\n                dialogData: updateCombatDialogs(\"Victory is yours!\", [], state.player, [])\n            }\n        });\n    } else {\n        dispatch({\n            type: 'SET_COMBAT',\n            payload: {\n                inCombat: true,\n                attackSlots: state.attackSlots,\n                turnOrder: state.turnOrder,\n                combatTurn: nextTurn,\n                player: { ...state.player, lastComment: playerComment },\n                dialogData: dialogData\n            }\n        });\n        console.log('After Dispatch - inCombat:', state.inCombat, 'Next Turn:', nextTurn?.name);\n        moveWaitingMonsters(state, dispatch);\n\n        if (current === state.turnOrder[state.turnOrder.length - 1]) {\n            resolveRound(state, dispatch);\n            calculateTurnOrder(state, dispatch);\n            roundNumber++;\n        }\n    }\n}\n\n\n\nconst Combat = ({ state, dispatch }) => {\n    const [combatActive, setCombatActive] = useState(false);\n\n    useEffect(() => {\n        if (state.inCombat && !combatActive) {\n            console.log('Combat Started - Initial State:', { combatTurn: state.combatTurn?.name, attackSlots: state.attackSlots });\n            setCombatActive(true);\n        }\n    }, [state.inCombat]);\n\n    const handleNextTurn = () => {\n        console.log('Next Turn Clicked');\n        combatStep(state, dispatch);\n    };\n\n    console.log('Combat Component - inCombat:', state.inCombat, 'Dialog Data:', state.dialogData);\n\n    return (\n        <div className=\"combat\">\n            <Dialog data={state.dialogData?.player || { name: state.player.name, hp: state.player.hp, comment: '' }} index=\"player\" />\n            {state.dialogData?.enemies?.map((enemy, i) => enemy && (\n                <Dialog key={i} data={enemy} index={i} />\n            ))}\n            {/* Debug div to show raw comment */}\n            <div style={{ color: 'red', fontSize: '20px' }}>\n                Raw Player Comment: {state.dialogData?.player?.comment || 'No comment yet'}\n            </div>\n            <button onClick={handleNextTurn}>Next Turn</button>\n        </div>\n    );\n};\nexport default Combat;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}